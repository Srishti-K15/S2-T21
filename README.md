# Path guidance for emergency evacuation

<!-- First Section -->
## Team Details
<details>
  <summary>Detail</summary>
  
> Semester: 3rd Sem B. Tech. CSE

> Section: S2

> Team ID: S2-T21

> Member 1:Pal Patel, 231CS240, palpatel.231cs240@nitk.edu.in, 9265254960

> Member 2: Pragya Paromita Barma, 231CS241, pragyaparomitabarma.231cs241@nitk.edu.in, 8160727736

> Member 3: Srishti Kumari, 231CS258, srishtikumari.231cs258@nitk.edu.in, 8310595970
</details>

<!-- Second Section -->
## Abstract
<details>
  <summary>Detail</summary>
   
   ### Motivation
The project is motivated by the critical need to have evacuation systems that
are smart, adaptable, and help save lives in emergencies; the complexity and overpopulation
of urban areas today call for allowing escape routes to be optimized even in unpredictable
conditions through efficient algorithms like Dijkstra’s. It can be incorporated into emergency
response systems to greatly increase the safety and efficiency of evacuations in life-threatening
situations such as fires. In emergencies such as building fires, time is rather critical. Finding the
safest and fastest route to evacuate, can be lifesaving. Conventional fire evacuation approaches
rely on static plans that may not be useful during real situations. Such hostile environments
require intelligent systems that must travel by the safest path possible and take into account
the continuously changing conditions generated by the fire.
  
  ### Problem Statement: 
  In the case of a fire outbreak inside a building, finding the safest and
quickest evacuation route for a person is critical. Given the building’s layout, the person must
navigate through hallways and rooms to reach an exit point while avoiding areas affected by
fire. We have developed a solution using Dijkstra’s algorithm to determine the shortest and
safest path from the person’s current location (source node) to the nearest exit (destination
node).
  
  ### Features:
 • This project aims to implement Dijkstra’s Algorithm practically by physically constructing
it using Verilog and modern circuit components [Galles, ].<br>
• It introduces a hardware approach to pathfinding, moving beyond theoretical concepts
[YouTube, ].<br>
• Unlike software-based implementations, this design utilizes parallelism to achieve higher
speed and efficiency in finding the shortest paths [GeeksforGeeks, ].<br>
• Logisim is used to draw and simulate circuits, making it possible to understand how the
algorithm works in hardware [Galles, ].<br>
• The project helps appreciate the management of resources and the complexity of the
circuits involved [GeeksforGeeks, ].
 
</details>

## Functional Block Diagram
<details>
  <summary>Detail</summary>
  
![blockDiagram drawio](https://github.com/user-attachments/assets/5cfe71dd-3014-4960-80ab-9303bc553d63)

</details>

<!-- Third Section -->
## Working
<details>
  <summary>Detail</summary>

  > Explain the working of your model with the help of a functional table (compulsory) followed by the flowchart.
</details>

<!-- Fourth Section -->
## Logisim Circuit Diagram
<details>
  <summary>Detail</summary>

  > Update a neat logisim circuit diagram
</details>

<!-- Fifth Section -->
## Verilog Code
<details>
  <summary>Detail</summary>

  > module dijkstra_subset(
    input reset,
    input [8:0] subset_cells,  // 9-bit input to represent cells (1 = included, 0 = excluded or blocked)
    input [3:0] source,        // 4-bit source node (3x3 grid -> 9 nodes, range: 0-8)
    input [3:0] destination,   // 4-bit destination node (range: 0-8)
    output reg [2:0] shortest_distance, // Shortest distance from source to destination
    output reg [8:0] path_out           // Path output (9 bits, 1 for each cell)
);

    reg [8:0] adj_matrix[8:0];   // Adjacency matrix for 3x3 grid
    reg [7:0] dist[8:0];         // Distance array
    reg [3:0] parent[8:0];       // Parent array for path reconstruction
    reg [8:0] visited;           // Visited array

    integer i, j;
    reg [3:0] current_node;
    reg [7:0] min_dist;
    reg [3:0] next_node;
// 9-bit representation of connections for a 3x3 grid
// 9 nodes in the grid
// Initialize the adjacency matrix in your module
initial begin
    adj_matrix[0] = 9'b000001010; // Node 0 connects to Node 1 (right) and Node 3 (down)
    adj_matrix[1] = 9'b000010101; // Node 1 connects to Node 0 (left), Node 2 (right), and Node 4 (down)
    adj_matrix[2] = 9'b000100010; // Node 2 connects to Node 1 (left) and Node 5 (down)
    adj_matrix[3] = 9'b001010001; 
    adj_matrix[4] = 9'b010101010; 
    adj_matrix[5] = 9'b100010100; 
    adj_matrix[6] = 9'b010001000; 
    adj_matrix[7] = 9'b101010000;
    adj_matrix[8] = 9'b010100000; 
end

    always @(reset or subset_cells or source or destination) begin
        if (reset) begin
            // Reset distances, visited, and path arrays
            for (i = 0; i < 9; i = i + 1) begin
                dist[i] = 8'hFF;
                parent[i] = 4'hF;
            end
            visited = 9'b000000000;
            shortest_distance = 8'hFF;
            path_out = 9'b000000000;
        end else begin
            // Adjust adjacency matrix based on subset_cells input
            for (i = 0; i < 9; i = i + 1) begin
                if (!subset_cells[i]) begin
                    // If a cell is not part of the subset or blocked, block all its connections
                    adj_matrix[i] = 9'b000000000;
                end
            end

            // Step 1: Set source distance to 0
            dist[source] = 8'h00;
            current_node = source;

            for (i = 0; i < 9; i = i + 1) begin
                // Mark the current node as visited
                visited[current_node] = 1'b1;

                // Update distances for neighbors of the current node
                for (j = 0; j < 9; j = j + 1) begin
                    if ((adj_matrix[current_node][j]==1) && !visited[j]) begin
                        //$display(adj_matrix[current_node][j]);
                        // If unvisited and an edge exists
                        if ((dist[current_node] + 8'h01) < dist[j]) begin
                            $display(i,j);
                            dist[j] = dist[current_node] + 8'h01; // Update distance (weight = 1)
                            parent[j] = current_node;             // Set parent
                        end
                    end
                end

                // Step 2: Find the next node with the smallest distance
                next_node = 4'hF; // Invalidate current node
                min_dist = 8'hFF; // Set minimum distance to infinity
                // check the logic over again ig there is some bug so dry run it again
                for (j = 0; j < 9; j = j + 1) begin
                    if (!visited[j] && (dist[j] < min_dist)) begin
                        min_dist = dist[j];
                        next_node = j;
                    end
                end

                // If no valid next node found, break the loop
                if (next_node == 4'hF) begin
                    i = 9; // End the loop
                end else begin
                    current_node = next_node;
                end
            end

            // Step 3: If we reached the destination, output the distance and path
if (dist[destination] != 8'hFF) begin
    shortest_distance = dist[destination];
    
    // Reconstruct path from destination to source
    // check the logic over here too the conditions of the for loop....
    path_out = 9'b000000000;
    current_node = destination;
    for (j = 0; current_node != source && j < 9 && current_node != 4'hF; j = j + 1) begin
        path_out = path_out | (1 << current_node);  // Set the bit corresponding to current_node
        current_node = parent[current_node];        // Move to the parent node
    end
    path_out = path_out | (1 << source); // Mark the source in the path
end else begin
    // No valid path found
    path_out = 9'b000000000;
end

        end
    end
endmodule
</details>

## References
<details>
  <summary>Detail</summary>
  
  > [https://www.cs.usfca.edu/galles/visualization/Dijkstra.html]<br/>
  >  [https://www.geeksforgeeks.org/dijkstras-shortest-path-algorithm-greedy-algo-7/]<br/>

</details>
